---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(knitr)
```

# bayesian.gtheory

<!-- badges: start -->

<!-- badges: end -->

The purpose of the `bayesian.gtheory` package is to provide an automated method for executing D-studies from Generalizability Theory through a Bayesian framework. The `dstudy_crossed1()` and ``dstudy_crossed2()` functions carry out reliability analysis for a fully crossed study design with one and two facets, respectively. Furthermore, the `dstudy_p_nested1()` function returns the reliability analysis for a fully random, partially nested (i:p) x o design, and the `dstudy_p_nested2()` function works for a fully random, partially nested p x (i:o) design.

## Installation

You can install the development version of bayesian.gtheory from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("t-clark04/bayesian.gtheory")
```

## Usage

Let's say you did a study in which you gave five different students a test with 3 different items on it, and you gave them that test on two separate occasions. You want to know the reliability with which you could generalize to each student's true score by averaging over x number of items and y number of occasions. This is called a reliability analysis. 

In regular (i.e. frequentist) Generalizability Theory, the result of such a reliability analysis is given as a point estimate -- the G-coefficient for absolute agreement (or $\Phi$). However, what if you wanted the reliability to be given as an interval instead? And what if you wanted to know the probability of the G-coefficient being above a certain threshold for your study? With frequentist G-theory, that's impossible, but not with Bayesian! 

The `dstudy_crossed2()` function calculates the G-coefficient for each combination of the two facets specified by the user, returning the result as both a point estimate (the median of the posterior distribution) and a credible interval (with quantiles specified by the user). Plus, the outputted data frame contains an explicit probability statement for each facet combination, specifying the probability of the G-coefficient being above an inputted threshold for that particular combination! The function even returns each of the variance components, both as a point estimate and as a credible interval. What's more, the user has the option of specifying prior distributions for any or all of the variance components through the ``set_prior()`` function in ``brms``or setting one of the facets in the study as fixed through the `facet.fixed` parameter, but the author decided to keep this example simple by leaving the default (null) priors and the fully random design.

```{r, echo = TRUE, results = "hide", message = FALSE, warning = FALSE}
# Loading in the package
library(bayesian.gtheory)

# Specifying some artificial data from a random P x I x O study design.
Person <- c(rep(1, 6), rep(2,6), rep(3,6), rep(4,6), rep(5,6))
Item <- c(rep(c(1,2,3), 10))
Occasion <- c(rep(c(1,1,1,2,2,2), 5))
Score <- c(6,6,7,6,5,5,1,3,1,2,2,2,5,5,4,5,4,5,10,9,8,10,10,10,5,6,6,6,5,6)

# Combining all of the data into one data frame.
sample_data <- data.frame(Person, Item, Occasion, Score)

# Running the bayesian_dstudy() function.
results <- dstudy_crossed2(data = sample_data, col.scores = "Score", col.subjects = "Person", col.facet1 = "Item", col.facet2 = "Occasion", seq1 = seq(1,5,1), seq2 = seq(1,3,1), facet.fixed = NULL, threshold = 0.7, warmup = 1000, iter = 4000, chains = 4, cores = 4)
```

```{r}
kable(results$gstudy)
```

```{r}
kable(results$dstudy)
```


How cool is that!

Thank you to Sven de Maeyer from the University of Antwerp for inspiring this Bayesian G-Theory package! See his blog post at https://svendemaeyer.netlify.app/posts/2021-04-generalizability/.

**Note #1**: The median is used as the measure of center for both the variance components and the reliability coefficients because these distributions are rarely normal (or even symmetric). The most appropriate measure of center for skewed distributions like these is the one which is most resistant to outliers, which is the median.

**Note #2**: Column names passed into the function must follow C++ naming conventions 
(i.e. only letters, numbers, or underscores; no spaces or hyphens!). Furthermore, 
the number of threads used for within-chain parallelization is set to 2 by 
default and cannot be changed. In general, the number of `cores` multiplied by 
the number of `threads` should not exceed the number of logical CPU cores in 
your operating system. Adjust the `cores` parameter accordingly! To check how 
many logical cores your operating system has, run parallel::detectCores()
in the console.
